package com.hclus.demoserver.server;

import com.hclus.demoserver.clustering.HierachicalClusterMiner;
import com.hclus.demoserver.clustering.InvalidClustersNumberException;
import com.hclus.demoserver.clustering.InvalidDepthException;
import com.hclus.demoserver.data.InvalidSizeException;
import com.hclus.demoserver.data.NoDataException;
import com.hclus.demoserver.data.Data;
import com.hclus.demoserver.distance.AverageLinkDistance;
import com.hclus.demoserver.distance.ClusterDistance;
import com.hclus.demoserver.distance.SingleLinkDistance;

import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;

/**
 * Classe per gestire le richieste del client.
 */
@Service
public class ServerService {
    /**
     * Dataset per memorizzare i dati caricati.
     */
    private Data data;
    /**
     * Oggetto per eseguire il clustering gerarchico.
     */
    private HierachicalClusterMiner clustering;

    /**
     * Gestisce il caricamento dei dati dal database.
     *
     * @param tableName  nome della tabella
     *
     * @return messaggio di stato
     */
    public String loadData(@RequestParam String tableName) {
        try {
            this.data = new Data(tableName);
            return "OK";
        } catch (NoDataException e) {
            return e.getMessage();
        }
    }

    /**
     * Gestisce l'operazione di clustering.
     *
     * @param depth  profondità del dendrogramma
     * @param distanceType  tipo di distanza
     *
     * @return rappresentazione del dendrogramma
     */
    public String performClustering(@RequestParam int depth, @RequestParam int distanceType) {
        if (data == null) {
            return "Dati non caricati";
        }

        try {
            this.clustering = new HierachicalClusterMiner(depth);
            ClusterDistance distance = distanceType == 1 ? new SingleLinkDistance() : new AverageLinkDistance();
            clustering.mine(data, distance);
            return clustering.toString(data);
        } catch (InvalidSizeException | InvalidClustersNumberException | InvalidDepthException | IllegalArgumentException e) {
            return e.getMessage();
        }
    }

    /**
     * Gestisce il caricamento del dendrogram da un file.
     *
     * @param fileName  nome del file
     *
     * @return rappresentazione del dendrogramma
     */
    public String loadDendrogramFromFile(@RequestParam String fileName) {
        try {
            clustering = HierachicalClusterMiner.loadHierachicalClusterMiner(fileName);
            //HierachicalClusterMiner savedCluster = HierachicalClusterMiner.loadHierachicalClusterMiner(fileName);

            if (data == null) {
                return "Dati non caricati.";
            }

            if (clustering.getDepth() > data.getNumberOfExample()) {
                return "Errore: numero di esempi maggiore della profondità del dendrogramma!";
            } else {
                return clustering.toString(data);
            }
        } catch (IOException | ClassNotFoundException | InvalidDepthException e) {
            return e.getMessage();
        }
    }

    /**
     * Gestisce il salvataggio del dendrogramma.
     *
     * @param fileName  nome del file
     *
     * @return messaggio di stato
     */
    public String saveDendrogram(@RequestParam String fileName) {
        if (clustering == null) {
            return "Errore: nessun dendrogramma disponibile per il salvataggio.";
        }

        try {
            clustering.salva(fileName); // salva il dendrogramma precedentemente generato
            return "Dendrogramma salvato correttamente.";
        } catch (FileAlreadyExistsException e) {
            return "Errore: Il file " + fileName + " esiste già.";
        } catch (IOException e) {
            return "Errore durante il salvataggio del dendrogramma: " + e.getMessage();
        }
    }

}